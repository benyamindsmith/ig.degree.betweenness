<p>Abstract</p>
<p>Patients at the Princess Margaret Cancer Centre who do not achieve
cure or remission following standard treatments often become candidates
for clinical trials. Patients who participate in a clinical trial may be
suitable for other studies. A key factor influencing further enrollment
in subsequent clinical trials is the collaboration network among patient
oncologists and most responsible physicians. Possible identification of
these collaboration networks can be achieved by analysis of patient
movements between intervention types studied in the clinical trials with
social network analysis (SNA) and community detection algorithms. The
present study evaluates three community detection algorithms:
Girvan-Newman, Louvain and an algorithm developed by the author.
Girvan-Newman identifies each intervention as their own community, while
Louvain groups interventions in a manner that is difficult to interpret.
In contrast, the author’s algorithm groups interventions in a way that
is both intuitive and informative. This lays the groundwork for future
subgroup analysis of clustered interventions.</p>
<h1 id="introduction">Introduction</h1>
<p>When cancer patients complete standard treatments at Princess
Margaret Cancer Centre and have not responded with being cured or in
remission, they become candidates for clinical trials. These clinical
trials are regulated studies registered by Health Canada<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> as
opposed to quality assurance studies<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a>. Patients who qualify
may be screen failures for other trials, have experienced progressive
disease or are receiving maintenance therapy and may be referred to a
clinical trial by their oncologist or most responsible physician. Ground
truth shows that collaboration networks between oncologists is a primary
factor for further engagement in subsequent clinical trials by patients
after completion of the given clinical trial they are enrolled in. A
possible approach to understanding the structure of these collaboration
networks is through use of social network analysis (SNA) and community
detection algorithms.</p>
<p>Social network analysis examines individual entities and their
relationships among them. The data is represented as a “graph” where
individual entities are referred to as “nodes” and their relationships
between them as “edges”, which may be directional if specified (see
Figure 1). A primary area of study in SNA is the analysis of
interconnectivity of nodes, called “communities” and identification of
clusters through the use of algorithms called “community detection
algorithms”. Rostami et al<sup>1</sup> (2023) note that there is no
specific model which describes exactly a “community” is. Generally,
community detection algorithms employ specific optimization strategies
to partition a large-scale complex network into a set of disjoint and
compact subgroups, often (but not always) without prior knowledge
regarding the number of subgroups and their sizes. Rostami et al further
note that it is commonly acknowledged that there is no unique community
detection algorithm that can accommodate all kinds of graphs because of
the inherent variability in network structures and their respective
objective(s).</p>
<figure>
<img src="./images/media/image1.png"
style="width:4.14212in;height:1.65018in"
alt="Two simple graphs with directed and undirected edges. Direction is noted by arrowheads at the end of the edges." />
<figcaption><p><strong>Figure 1.</strong> Two simple graphs with
directed and undirected edges. Direction is noted by arrowheads at the
end of the edges.</p></figcaption>
</figure>
<p>Application of community detection algorithms with oncology clinical
trial data has been preformed in the past. Georgiev et al<sup>2</sup>
(2011) applied the Girvan-Newman<sup>3</sup> (2002) algorithm and noted
lack of cohesion among researchers who studied treatments for Multiple
Myelnoma. Haq and Wang<sup>4</sup> (2016) applied the Louvain algorithm
(by Blondel et al<sup>5</sup> (2008)) to identify communities of cancer
patients with significantly different survival curves. The present study
applies SNA and compares multiple community detection algorithms to
identify collaboration networks between oncologists through the
interventions studied in clinical trials via enrollment data of patients
in multiple, non-overlapping clinical trials at University Health
Network’s Princess Margaret Cancer Centre (PM). Inspired by work from
Gorgiev et al (2011), Haq and Wang (2016), Ostovari and Yu<sup>6</sup>
(2019) and Bissoyi and Patra<sup>7</sup> (2020) this research considers
the Girvan-Newman and Louvain algorithms and compares them to an
author-developed algorithm, referred to as “Smith-Pittman”<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, to
identify collaboration networks between clinical trials classified by
intervention.</p>
<h1 id="materials-and-methods">Materials and Methods</h1>
<h2 id="the-data">The Data</h2>
<p>The data is a result of multiple data source integration which was
undertaken from the Cancer Registry and PM Clinical Research Record and
is anonymized. The data spans patient enrollments in oncology clinical
trials between January 1st 2016 and December 31st 2018. In this time
span, there were 2970 patients enrolled in 515 clinical trials involving
41 principal investigators. For identification of collaboration networks
between oncologists, the analytic sample only consists of patients who
have been enrolled in more than one clinical trial over within the time
span the data captures. The resulting sample consists of 389 patients
enrolled in 288 clinical trials. Among the clinical trials, some
interventions can be classified into broader categories consisting of
Targeted therapies, Immunotherapy, this has been identified in the data
with “T:” and “I:” prefixes respectively. The clinical trials are
classified by intervention type resulting, in 16 intervention types and
470 patient enrollments. With this classification, the patient referral
graph is constructed (see Figure 2).</p>
<p>The analysis is preformed with the <code>R</code> programming
language and makes use of an extensive array of libraries and
dependencies. The primary libraries that are used are
<code>igraph</code>, <code>tidyverse</code>, and <code>tidygraph</code>.
For the complete script, refer to see Appendix - Program Syntax.</p>
<p><img src="./images/media/image2.png"
style="width:5.88333in;height:4.65in"
alt="Patient movement between clinical trials classified by intervention type at PM. Nodes indicate the treatment type and the labeled edges indicate movement of patients from trials in a given intervention to another or to the same type of intervention. Among the clinical trials, some interventions can be classified into broader categories consisting of Targeted therapies, Immunotherapy, this has been identified in the data with “T:” and “I:” prefixes respectively." /></p>
<p><strong>Figure 2.</strong> Patient movement between clinical trials
classified by intervention type at PM. Nodes indicate the treatment type
and the labeled edges indicate movement of patients from trials in a
given intervention to another or to the same type of intervention. Among
the clinical trials, some interventions can be classified into broader
categories consisting of Targeted therapies or Immunotherapy. This has
been identified in the data with “T:” and “I:” prefixes
respectively.</p>
<h2 id="methods">Methods</h2>
<p>The goal of using community detection algorithms with this data is to
identify working groups among interventions based on the movement
(incoming and outgoing referrals) of patients between them. These
movements in the network are understood through the measures that are
considered by the community detection algorithms’ optimization
strategies. While the Girvan-Newman, Louvain and Smith-Pittman
algorithms differ in their approaches to identification of collaboration
networks, their identification strategies are based on maximization of
modularity, <span class="math inline"><em>Q</em></span>- a measure that
scores the degree of segregation within a network through tightly
connected communities or clusters (See Newman<sup>8</sup> (2006)).</p>
<p>The mathematical representation of modularity is defined in the
<code>igraph</code> R package<sup>9</sup> (2006) as:</p>
<p><span class="math display">$$Q = \frac{1}{m}\sum_{i,j}^{}\left(
A_{ij} - \frac{k_{i}^{\text{out}}k_{j}^{\text{in}}}{m}
\right)\delta\left( c_{i},c_{j} \right)$$</span></p>
<p>Where <span class="math inline"><em>m</em></span> is the number of
edges (patient movements), <span
class="math inline"><em>A</em><sub><em>i</em><em>j</em></sub></span> is
the number of connections shared by nodes <span
class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span> (movements between interventions
<span class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span>), <span
class="math inline"><em>k</em><sub><em>i</em></sub><sup>out</sup></span>
and <span
class="math inline"><em>k</em><sub><em>j</em></sub><sup>in</sup></span>
are the number of edges coming out from node <span
class="math inline"><em>i</em></span> and going into node <span
class="math inline"><em>j</em></span> (patient movements from
intervention <span class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span>) and <span
class="math inline"><em>δ</em>(<em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>)</span>
is an indicator variable identifying if nodes <span
class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span> are connected- either directly or
through another node (if there is a patient movement between
interventions <span class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span> either directly or through some
other intervention). For directed graphs, <span
class="math inline"><em>k</em><sub><em>i</em></sub><sup>out</sup></span>
and <span
class="math inline"><em>k</em><sub><em>j</em></sub><sup>in</sup></span>
are simply the number of connected edges possessed by nodes <span
class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span> respectfully. For a more
comprehensive overview modularity and other measures in social network
analysis, see Newman (2006), Wasserman and Faust<sup>10</sup> (1994) and
Latora et al<sup>11</sup> (2017).</p>
<h3 id="girvan-newman">Girvan-Newman</h3>
<p>The Girvan-Newman algorithm is based on evaluation of the edges of a
social network through edge-betweenness centrality. Edge-betweenness
centrality is defined by Girvan and Newman (2002) as the number of the
shortest paths that go through an edge in a graph divided by the total
number of shortest paths between nodes <span
class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span>. Each edge in the graph associated
with has their own edge-betweenness centrality value. The igraph (2006)
documentation defines edge-betweenness centrality for edge <span
class="math inline"><em>e</em></span> in a social network in
mathematical terms as:</p>
<p><span class="math display">$$\sum_{i \neq
j}^{}g_{iej}/g_{ij}$$</span></p>
<p>Where <span
class="math inline"><em>g</em><sub><em>i</em><em>j</em></sub></span> is
the number of shortest paths between nodes <span
class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span> (patient movements between
interventions <span class="math inline"><em>i</em></span> and <span
class="math inline"><em>j</em></span>, either directly or through some
other intervention(s)), and <span
class="math inline"><em>g</em><sub><em>i</em><em>e</em><em>j</em></sub></span>
is the number of shortest paths which pass through the edge <span
class="math inline"><em>e</em></span>. Figure 3 provides an illustration
of a simple network and the edge with the highest edge-betweenness
centrality highlighted in red.</p>
<p><img src="./images/media/image3.png"
style="width:3.03158in;height:2.02105in"
alt="A simple network demonstrating an edge with a high edge-betweenness centrality, highlighted in red. The network consists of two densely connected clusters, with the red edge serving as the sole connection between them. This edge is crucial for communication between the two clusters, as most shortest paths that connect nodes from opposite clusters must pass through it." /></p>
<p><strong>Figure 3.</strong> A simple network demonstrating an edge
with a high edge-betweenness centrality, highlighted in red. The network
consists of two densely connected clusters, with the red edge serving as
the sole connection between them. This edge is crucial for communication
between the two clusters, as most of the shortest paths that connect
nodes from opposite clusters pass through it.</p>
<p>Edge betweenness can be calculated for directed and undirected edges.
As a result, the Girvan-Newman algorithm can be applied to directed or
undirected graphs without any transformations. The steps the
Girvan-Newman algorithm follows are:</p>
<ol type="1">
<li><p>Calculate edge-betweenness centrality for all edges in the
network.</p></li>
<li><p>Find the edge with the highest edge-betweenness centrality and
remove it from the network.</p></li>
<li><p>Recalculate edge-betweenness centrality for all remaining
edges.</p></li>
<li><p>Repeat from step 2.</p></li>
</ol>
<p>Girvan-Newman can be used when community structure is known and will
classify nodes into a pre-deterimined number of communities based on the
hierarchy produced by the algorithm (see Girvan and Newman 2002). When
the community structure is not known, modularity is evaluated at after
each iteration of the algorithm and the grouping of nodes into distinct
communities is selected via modularity maximization.</p>
<h3 id="louvain">Louvain</h3>
<p>The Louvain algorithm (by Blondel et al 2008) operates in two
distinct phases. (i) In the first phase, each node in the network is
considered as their own community, resulting in the initial partition
with as many communities as there are nodes. The algorithm then assesses
the potential modularity gain for each node <span
class="math inline"><em>i</em></span> if it were to leave its current
community and join the community of node <span
class="math inline"><em>j</em></span>. After evaluating the potential
modularity gain across all communities, node <span
class="math inline"><em>i</em></span> is reassigned to the community of
node <span class="math inline"><em>j</em></span> where the modularity
increase is maximized. The process is iteratively and sequentially
applied for all nodes until no further improvement can be achieved. This
first phase stops when a local maximum of modularity is reached, meaning
no individual node moves can enhance modularity. (ii) The second phase
involves constructing a new network represent the communites identified
in the first phase. Links between nodes of the same community are viewed
as “self-loops” for the commmunity in the new network. Once this second
phase is complete, the first phase of the algorithm can be reapplied.
The combination of these two phases is referred to as a “pass”. The
algorithm terminates when there is no other local maxima in modularity
to be achieved in subsequent passes.</p>
<p>A key limitation of the Louvain algorithm is that it is generally
programmed to work only with undirected graphs<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. In
order to apply the Louvain algorithm to a directed graph, it must first
be converted to an undirected graph. Figure 4 is a reproduction of
Blodel et al’s (2008) illustration of the algorithm.</p>
<p><img src="./images/media/image4.png"
style="width:5.83333in;height:3.44184in"
alt="Reproduced illustration of the Louvain Algorithm (originally designed by Blondel et al (2008))." /></p>
<p><strong>Figure 4.</strong> Reproduced illustration of the Louvain
algorithm (originally designed by Blondel et al (2008)).</p>
<h3 id="smith-pittman">Smith-Pittman</h3>
<p>The “Smith-Pittman” algorithm is a modification of the Girvan-Newman
algorithm where degree centrality is considered. Degree centrality of a
node is simply defined as the number of connections a node has within a
given network (see figure 5). The algorithm proceeds through the
following steps:</p>
<ol type="1">
<li><p>Calculate the degree centrality for each node and the
edge-betweenness centrality of all edges in the network.</p></li>
<li><p>Identify the subgraph associated with the node that has the
highest degree centrality.</p></li>
<li><p>Remove the edge possessing the highest calculated
edge-betweenness centrality.</p></li>
<li><p>Recalculate the degree centrality for all nodes and the
edge-betweenness centrality for the remaining edges in the
network.</p></li>
<li><p>Repeat from step 2.</p></li>
</ol>
<p>Figure 6 provides a visual representation of this algorithm. Like
Girvan-Newman, the Smith-Pittman algorithm can be applied both directed
and undirected graphs. Conceptually, the algorithm can be specified to
terminate once a pre-determined number of communities has been
identified. However, its primary design is for use in an unsupervised
setting, where clusters are identified through the maximization of
modularity as evaluated after each iteration of the algorithm.</p>
<figure>
<img src="./images/media/image5.png"
style="width:2.02105in;height:2.02105in"
alt="A simple network highlighting node degree. The center node (colored red) posseses the highest number of connections and as a result posseses the highest degree and degree centrality index." />
<figcaption><p><strong>Figure 5.</strong> A simple network highlighting
node degree. The center node (colored red) posseses the highest number
of connections and as a result posseses the highest degree and degree
centrality index.</p></figcaption>
</figure>
<figure>
<img src="./images/media/image6.png"
style="width:5.83333in;height:2.29042in"
alt="The Smith-Pittman Algorithm" />
<figcaption><p><strong>Figure 6.</strong> Illustration of the
Smith-Pittman algorithm. Highlighted convex hulls denote the
identification of distinct communities.</p></figcaption>
</figure>
<h1 id="results">Results</h1>
<p>Figures 7-9 show the identified communities by the algorithms by
highlighting convex hulls over the grouped interventions. Tables 1-3
shows the grouping of interventions into communities and the breakdown
of the number of incoming and outgoing patient referrals for each
intervention studied by clinical trials in the PM clinical trial
enrollment dataset. Figure 7 demonstrates that the Girvan-Newman
algorithm identified each intervention as a separate community (<span
class="math inline"><em>Q</em>=</span> 0.044) . This result is
particularly uninformative, as it is equivalent to not applying any
community detection method for collaboration network identification
between interventions. Figure 8 shows that the Louvain algorithm groups
interventions into four distinct working groups, achieving the highest
modularity score (<span class="math inline"><em>Q</em>=</span> 0.177).
However, the underlying rationale and meaning behind these groupings
remains unclear beyond clustering interventions with the objective to
maximize modularity.</p>
<p>Figure 9 shows that the Smith-Pittman algorithm (<span
class="math inline"><em>Q</em>=</span> 0.08) identifies eight
communities. Six of these communities consist of individual
interventions - namely T: Small Molecule, I:MAbs<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>
Checkpoint, I:Combined, I:MAbs Targeting, Combined Modality and
Radioconjugate - while the remaining two of the communities encompass
multiple interventions. The interpretation the communities identified by
the Smith-Pittman algorithm can be understood through the degree of
connectivity among interventions within these communities. Communities
comprising of individual interventions either have the highest or a
substantial number of patient referrals, whether incoming from or
outgoing to other interventions, or they have the least. Figure 10
illustrates the distribution of interventions by patient referrals,
ordered from smallest to largest and highlights the thresholds beyond
which single intervention communities are positioned. The interpretation
of the communities identified by the Smith-Pittman algorithm suggests
that the existence of both highly connected and less connected
interventions, as well as broader groups corresponding to typical
intervention types. This interpretation offers an intuitive
understanding related to the formation of collaboration networks being a
function of intervention “popularity” - i.e. patient referrals outgoing
and incoming to and from other interventions.</p>
<figure>
<img src="./images/media/image7.png"
style="width:5.42518in;height:4.62516in"
alt="Detected Communities via Girvan-Newman with modularity Maximizaton. 16 distinct communities." />
<figcaption><p><strong>Figure 7:</strong> Detected communities via
Girvan-Newman with modularity maximization. 16 distinct
communities.</p></figcaption>
</figure>
<p><strong>Table 1.</strong> Girvan-Newman communities identified. Each
intervention is their own community.</p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 20%" />
<col style="width: 23%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>Intervention</th>
<th style="text-align: right;">Refferalls In</th>
<th style="text-align: right;">Referrals Out</th>
<th style="text-align: right;">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chemotherapy</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">14</td>
</tr>
<tr>
<td>Combined Modality</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
</tr>
<tr>
<td>Drug Repurposing</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">10</td>
</tr>
<tr>
<td>I: Adoptive Cell Transfer</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">13</td>
</tr>
<tr>
<td>I: Anti Cancer Vaccine</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">11</td>
</tr>
<tr>
<td>I: Combined</td>
<td style="text-align: right;">54</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">76</td>
</tr>
<tr>
<td>I: MAbs Checkpoint</td>
<td style="text-align: right;">92</td>
<td style="text-align: right;">147</td>
<td style="text-align: right;">239</td>
</tr>
<tr>
<td>I: MAbs Co-Stimulatory</td>
<td style="text-align: right;">31</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">53</td>
</tr>
<tr>
<td>I: MAbs Targeting</td>
<td style="text-align: right;">31</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">53</td>
</tr>
<tr>
<td>I: Oncolytic Virus</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">9</td>
</tr>
<tr>
<td>I: Other</td>
<td style="text-align: right;">25</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">31</td>
</tr>
<tr>
<td>Radioconjugate</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
</tr>
<tr>
<td>T: Antibody-Drug Conjugate</td>
<td style="text-align: right;">18</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">28</td>
</tr>
<tr>
<td>T: Combined</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">17</td>
</tr>
<tr>
<td>T: Monoclonal Antibody</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">22</td>
</tr>
<tr>
<td>T: Small Molecule</td>
<td style="text-align: right;">174</td>
<td style="text-align: right;">188</td>
<td style="text-align: right;">362</td>
</tr>
</tbody>
</table>
<p><img src="./images/media/image8.png"
style="width:6.50855in;height:5.73352in"
alt="Detected Communities via Louvain algorithm with modularity Maximizaton. 4 distinct communities." /></p>
<p><strong>Figure 8:</strong> Detected communities via Louvain algorithm
with modularity maximization. 4 distinct communities.</p>
<p><strong>Table 2.</strong> Louvain communities identified and their
grouped interventions.</p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 20%" />
<col style="width: 23%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>Intervention</th>
<th style="text-align: right;">Refferalls In</th>
<th style="text-align: right;">Referrals Out</th>
<th style="text-align: right;">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="4">Community: 1</td>
</tr>
<tr>
<td>Drug Repurposing</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">10</td>
</tr>
<tr>
<td>I: Other</td>
<td style="text-align: right;">25</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">31</td>
</tr>
<tr>
<td>T: Monoclonal Antibody</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">22</td>
</tr>
<tr>
<td>T: Small Molecule</td>
<td style="text-align: right;">174</td>
<td style="text-align: right;">188</td>
<td style="text-align: right;">362</td>
</tr>
<tr>
<td colspan="4">Community: 2</td>
</tr>
<tr>
<td>Combined Modality</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
</tr>
<tr>
<td>I: Adoptive Cell Transfer</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">13</td>
</tr>
<tr>
<td>I: Anti Cancer Vaccine</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">11</td>
</tr>
<tr>
<td>I: MAbs Checkpoint</td>
<td style="text-align: right;">92</td>
<td style="text-align: right;">147</td>
<td style="text-align: right;">239</td>
</tr>
<tr>
<td>Radioconjugate</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
</tr>
<tr>
<td>T: Antibody-Drug Conjugate</td>
<td style="text-align: right;">18</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">28</td>
</tr>
<tr>
<td colspan="4">Community: 3</td>
</tr>
<tr>
<td>I: Combined</td>
<td style="text-align: right;">54</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">76</td>
</tr>
<tr>
<td>I: MAbs Co-Stimulatory</td>
<td style="text-align: right;">31</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">53</td>
</tr>
<tr>
<td>I: Oncolytic Virus</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">9</td>
</tr>
<tr>
<td colspan="4">Community: 4</td>
</tr>
<tr>
<td>Chemotherapy</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">14</td>
</tr>
<tr>
<td>I: MAbs Targeting</td>
<td style="text-align: right;">31</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">53</td>
</tr>
<tr>
<td>T: Combined</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">17</td>
</tr>
</tbody>
</table>
<figure>
<img src="./images/media/image9.png"
style="width:5.80851in;height:4.76682in"
alt="Detected Communities via Smith-Pittman algorithm with modularity Maximizaton. 8 distinct communities." />
<figcaption><p><strong>Figure 9.</strong> Detected communities via
Smith-Pittman algorithm with modularity maximization. 8 distinct
communities.</p></figcaption>
</figure>
<p><img src="./images/media/image10.png"
style="width:5.72576in;height:4.44226in"
alt="Referral distribution among interventions" /></p>
<p><strong>Figure 10.</strong> Referral distribution among
interventions. Interventions outside the boundaries (T: Small Molecule,
I:MAbs Checkpoint, I: Combined, I:Mabs Targeting, Radioconjugate and
Combined Modality) are each identified as individual communities, while
interventions within them are identified as belonging to communities
consisting of multiple interventions.</p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 20%" />
<col style="width: 23%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr>
<th>Intervention</th>
<th style="text-align: right;">Refferalls In</th>
<th style="text-align: right;">Referrals Out</th>
<th style="text-align: right;">Total</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="4">Community: 1</td>
</tr>
<tr>
<td>T: Small Molecule</td>
<td style="text-align: right;">174</td>
<td style="text-align: right;">188</td>
<td style="text-align: right;">362</td>
</tr>
<tr>
<td colspan="4">Community: 2</td>
</tr>
<tr>
<td>I: MAbs Checkpoint</td>
<td style="text-align: right;">92</td>
<td style="text-align: right;">147</td>
<td style="text-align: right;">239</td>
</tr>
<tr>
<td colspan="4">Community: 3</td>
</tr>
<tr>
<td>Chemotherapy</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">14</td>
</tr>
<tr>
<td>I: Adoptive Cell Transfer</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">13</td>
</tr>
<tr>
<td>I: Anti Cancer Vaccine</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">11</td>
</tr>
<tr>
<td>I: MAbs Co-Stimulatory</td>
<td style="text-align: right;">31</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">53</td>
</tr>
<tr>
<td>I: Oncolytic Virus</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">5</td>
<td style="text-align: right;">9</td>
</tr>
<tr>
<td>T: Antibody-Drug Conjugate</td>
<td style="text-align: right;">18</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">28</td>
</tr>
<tr>
<td>T: Combined</td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">8</td>
<td style="text-align: right;">17</td>
</tr>
<tr>
<td colspan="4">Community: 4</td>
</tr>
<tr>
<td>I: Combined</td>
<td style="text-align: right;">54</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">76</td>
</tr>
<tr>
<td colspan="4">Community: 5</td>
</tr>
<tr>
<td>I: MAbs Targeting</td>
<td style="text-align: right;">31</td>
<td style="text-align: right;">22</td>
<td style="text-align: right;">53</td>
</tr>
<tr>
<td colspan="4">Community: 6</td>
</tr>
<tr>
<td>Drug Repurposing</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">10</td>
</tr>
<tr>
<td>I: Other</td>
<td style="text-align: right;">25</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">31</td>
</tr>
<tr>
<td>T: Monoclonal Antibody</td>
<td style="text-align: right;">6</td>
<td style="text-align: right;">16</td>
<td style="text-align: right;">22</td>
</tr>
<tr>
<td colspan="4">Community: 7</td>
</tr>
<tr>
<td>Combined Modality</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
</tr>
<tr>
<td colspan="4">Community: 8</td>
</tr>
<tr>
<td>Radioconjugate</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
</tr>
</tbody>
</table>
<p><strong>Table 3.</strong> Smith-Pittman communities identified and
their grouped interventions.</p>
<h1 id="discussion">Discussion</h1>
<p>Where the Girvan-Newman algorithm failed to identify communities, the
Louvain and Smith-Pittman algorithms succeeded. A possible explanation
for this discrepancy lies in the nature of the data analyzed, which
includes patient referrals to clinical trials that investigate the same
intervention types as the clinical trials patients were previously
enrolled in. In graph theory, such referrals are represented as
“self-loops” and introduce complexity in the network. The Girvan-Newman
algorithm- whose original design was not for complex networks -
struggles in such contexts, leading to its failure to group multiple
interventions into communities based on modularity maximization.</p>
<p>The Louvain algorithm successfully detected communities, however, the
resulting groups were difficult to interpret. This difficulty arises
because the Louvain algorithm bases its community selection purely on
modularity maximization and does not consider the direction of patient
movements the underlying structural or functional significance of
particular interventions in the context of the network. The primary
advantage of the Louvain algorithm is its efficency in preforming
community detection on large networks. It has been widely used in
applications such as the Twitter Social Network (Pujol et al. 2009)
which consisted of 2.4 million nodes and 38 million links and mobile
phone network data (Greene et al. 2010) with 4 million nodes, 100
million links. These networks are orders of magnitude larger than the
patient referral network analyzed in this study, highlighting the
scalability of the Louvain algorithm. However, utility of such a
algorithm is limited in smaller, more specialized networks where
interpretability and justification of communities identified is
important.</p>
<p>Contrasting, the Smith-Pittman algorithm directly addresses
connectivity of interventions studied in the clinical trials by
incorperating degree centrality and edge-betweenness centrality. This
approach allows for the identification of communities with a more
ordered structure, distinguishing between highly connected and minor
interventions as they reflect the relational dynamics in the network.
The results from the Smith-Pittman algorithm are promising, however the
results from this analysis alone is insufficient to establish
generalizability of the algorithm. To fully assess its usefulness, a
formal simulation study and further application of the Smith-Pittman
algorithm in diverse settings is necessary. Additionally, the practical
value of identified communities will become evident when they are
applied as grouping variables in downstream analysis, such as outcome
prediction or intervention effectiveness studies.</p>
<p>Further research should focus on subgroup analysis and exploring
extensions back to traditional statistical methods, such as regression
and survival analysis. This research can further validate the utility of
the identified communities and use of SNA and community detection
algorithms in clinical research settings. The results of the
Smith-Pittman algorithm lay the groundwork for these efforts and
potentially offer a robust tool for community detection in social and
complex networks. Further work with the identified communities should
involve assessment of the impact of community structure on patient
outcomes and identify if there are any structural inequities present in
the clinical trial enrollments. This line of research can lead to the
identification of collaboration networks that improve patient care in
clinical settings.</p>
<h1 id="references">References</h1>
<p>1. Rostami, M., Oussalah, M., Berahmand, K. &amp; Farrahi, V.
Community Detection Algorithms in Healthcare Applications: A Systematic
Review. IEEE Access 11, 30247–30272 (2023).</p>
<p>2. Georgiev, H., Tsalatsanis, A., Kumar, A. &amp; Djulbegovic, B.
Social Network Analysis (SNA) of Research Programs In Multiple Myeloma
(MM). Blood 118, 3144–3144 (2011).</p>
<p>3. Girvan, M. &amp; Newman, M. E. J. Community structure in social
and biological networks. Proceedings of the National Academy of Sciences
99, 7821–7826 (2002).</p>
<p>4. Haq, N. &amp; Wang, Z. J. Community detection from genomic
datasets across human cancers. in 2016 IEEE Global Conference on Signal
and Information Processing (GlobalSIP) 1147–1150 (IEEE, 2016).
doi:10.1109/GlobalSIP.2016.7906021.</p>
<p>5. Blondel, V. D., Guillaume, J.-L., Lambiotte, R. &amp; Lefebvre, E.
Fast unfolding of communities in large networks. Journal of Statistical
Mechanics: Theory and Experiment 2008, P10008 (2008).</p>
<p>6. Ostovari, M. &amp; Yu, D. Impact of care provider network
characteristics on patient outcomes: Usage of social network analysis
and a multi-scale community detection. PLoS One 14, e0222016 (2019).</p>
<p>7. Bissoyi, S. &amp; Patra, M. R. Community Detection in a
Patient-Centric Social Network. in 171–182 (2021).
doi:10.1007/978-981-15-7394-1_17.</p>
<p>8. Newman, M. E. J. Modularity and community structure in networks.
Proceedings of the National Academy of Sciences 103, 8577–8582
(2006).</p>
<p>9. Csardi, G. &amp; Nepusz, T. The igraph software package for
complex network research. InterJournal, Complex Systems 1695 (2006).</p>
<p>10. Wasserman, S. &amp; Faust, K. Social Network Analysis. (Cambridge
University Press, 1994). doi:10.1017/CBO9780511815478.</p>
<p>11. Latora, V., Nicosia, V. &amp; Russo, G. Complex Networks.
(Cambridge University Press, 2017). doi:10.1017/9781316216002.</p>
<p>12. Dugué, N. &amp; Perez, A. Direction matters in complex networks:
A theoretical and applied study for greedy modularity optimization.
Physica A: Statistical Mechanics and its Applications 603, 127798
(2022).</p>
<p> </p>
<h1 id="appendix---program-syntax">Appendix - Program Syntax</h1>
<pre><code># Pre-Processing Script
library(tidyverse)
library(tidygraph)
library(igraph)
library(ig.degree.betweenness) # Author developed methodology, pending public release
library(plyr) # for join_all
library(gt) # for tables
# Load R Data
real_df &lt;- readRDS(&quot;C:/Users/ben29/OneDrive - University of Toronto/UofT/Fall2023/CHL5208/UHN/DLSPH_ClinT_subjects_AEs_2016_2018_19Dec2023.rds&quot;)

real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- MAbs-immunomodulatory-Checkpoint&quot;)] &lt;- &quot;I: MAbs Checkpoint&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Tageted therapy- antibody-drug conjugate&quot;)] &lt;- &quot;T: Antibody-Drug Conjugate&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- MAbs-immunomodulatory-Co-Stimulatory&quot;)] &lt;- &quot;I: MAbs Co-Stimulatory&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- Immuno + other investigational agent&quot;)] &lt;- &quot;I: Combined&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Targeted therapy - combined (small molecule + monoclonal antibody)&quot;)] &lt;- &quot;T: Combined&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- MAbs- Tumour-targeting (includes immunoconjugates, naked MAbs)&quot;)] &lt;- &quot;I: MAbs Targeting&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Targeted therapy - small molecule&quot;)] &lt;- &quot;T: Small Molecule&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- Other&quot;)] &lt;- &quot;I: Other&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Targeted therapy - monoclonal antibody&quot;)] &lt;- &quot;T: Monoclonal Antibody&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- Adoptive Cell Transfer (e.g. TILS)&quot;)] &lt;- &quot;I: Adoptive Cell Transfer&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- combined types&quot;)] &lt;- &quot;I: Combined&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Other - drug repurposing&quot;)] &lt;- &quot;Drug Repurposing&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- Cytokines (eg. INFa, IL, Hematopoietic growth factors)&quot;)] &lt;- &quot;I: MAbs Co-Stimulatory&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Multiple- Biomarker Targeted&quot;)] &lt;- &quot;T: Combined&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- Anti Cancer Vaccine- Peptide based vaccine&quot;)] &lt;- &quot;I: Anti Cancer Vaccine&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Chemotherapy&quot;)] &lt;- &quot;Chemotherapy&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- Oncolytic Virus&quot;)] &lt;- &quot;I: Oncolytic Virus&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Combined modality (e.g chemoradiation, EBRT+Brachy)&quot;)] &lt;- &quot;Combined Modality&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Immunotherapy- Anti Cancer Vaccine- Gene Therapy (e.g DNA/RNA vaccines)&quot;)] &lt;- &quot;I: Anti Cancer Vaccine&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Other - radioconjugate&quot;)] &lt;- &quot;Radioconjugate&quot;;
real_df$New_Intervention_Name[real_df$New_Intervention_Name %in% c(&quot;Homonal Treatment&quot;)] &lt;- &quot;Drug Repurposing&quot;;


intervention_graph_real_directed&lt;-  real_df |&gt;
  dplyr::group_by(Subject_ID,Study_ID) |&gt;
  dplyr::filter(dplyr::n() &gt; 1) |&gt;
  dplyr::distinct(pick(Subject_ID,Study_ID),.keep_all = TRUE) |&gt;
  dplyr::ungroup() |&gt;
  dplyr::filter(Subject_ID %in% names(table(Subject_ID))[table(Subject_ID) &gt; 1]) |&gt;
  dplyr::group_by(Subject_ID) |&gt;
  dplyr::group_split() |&gt;
  lapply(function(x) x |&gt;
           dplyr::mutate(x, index = 1:nrow(x),
                         direction = ifelse(index%%2 == 1, &quot;from&quot;,&quot;to&quot;))) |&gt;
  do.call(what = rbind) |&gt;
  dplyr::select(Subject_ID, Study_ID, direction, New_Intervention_Name) |&gt;
  tidyr::pivot_wider(
    id_cols = c(Subject_ID),
    names_from = direction,
    values_from = c(New_Intervention_Name, Study_ID)) |&gt;
  dplyr::rename(from = New_Intervention_Name_from,
                to = New_Intervention_Name_to,
                Study_ID = Study_ID_from) |&gt;
  tidyr::unnest(from) |&gt;
  tidyr::unnest(to) |&gt;
  tidyr::unnest(Study_ID) |&gt;
  tidyr::unnest(Study_ID_to) |&gt;
  dplyr::mutate(from = str_wrap(from, width = 30),
                to = str_wrap(to, width = 30)) |&gt;
  #dplyr::group_by(from, to) |&gt;
  #dplyr::count(name=&quot;Num_Patients&quot;) |&gt;
  tidygraph::as_tbl_graph(directed = TRUE) |&gt;
  igraph::as.igraph()


intervention_graph_real_undirected&lt;-  real_df |&gt;
  dplyr::group_by(Subject_ID) |&gt;
  dplyr::filter(dplyr::n() &gt; 1) |&gt;
  dplyr::distinct(pick(Subject_ID,Study_ID),.keep_all = TRUE) |&gt;
  dplyr::ungroup() |&gt;
  dplyr::filter(Subject_ID %in% names(table(Subject_ID))[table(Subject_ID) &gt; 1]) |&gt;
  dplyr::group_by(Subject_ID) |&gt;
  dplyr::group_split() |&gt;
  lapply(function(x) x |&gt;
           dplyr::mutate(x, index = 1:nrow(x),
                         direction = ifelse(index%%2 == 1, &quot;from&quot;,&quot;to&quot;))) |&gt;
  do.call(what = rbind) |&gt;
  dplyr::select(Subject_ID, Study_ID, direction, New_Intervention_Name) |&gt;
  tidyr::pivot_wider(
    id_cols = c(Subject_ID),
    names_from = direction,
    values_from = c(New_Intervention_Name, Study_ID)) |&gt;
  dplyr::rename(from = New_Intervention_Name_from,
                to = New_Intervention_Name_to,
                Study_ID = Study_ID_from) |&gt;
  tidyr::unnest(from) |&gt;
  tidyr::unnest(to) |&gt;
  tidyr::unnest(Study_ID) |&gt;
  tidyr::unnest(Study_ID_to) |&gt;
  dplyr::mutate(from = str_wrap(from, width = 30),
                to = str_wrap(to, width = 30)) |&gt;
  #dplyr::group_by(from, to) |&gt;
  #dplyr::count(name=&quot;Num_Patients&quot;) |&gt;
  tidygraph::as_tbl_graph(directed = FALSE) |&gt;
  igraph::as.igraph()


own_subj_mult_studies_check &lt;- real_df |&gt;
  dplyr::distinct(Subject_ID, Study_ID) |&gt;
  dplyr::group_by(Subject_ID) |&gt;
  dplyr::count(name=&quot;N_Studies&quot;) |&gt;
  dplyr::filter(N_Studies &gt; 1)
#389 participants enrolled in more than 1 study in 470 instances;



### Limit analysis to participants who enrolled in more than 1 clinical trial;


own &lt;- real_df |&gt;
  # Adding this line because Tyler has it as well. 
  dplyr::mutate(eligible = &quot;eligible&quot;) |&gt;
  dplyr::filter(Subject_ID %in% unique(own_subj_mult_studies_check$Subject_ID)) |&gt;
  dplyr::select(
    &quot;Subject_ID&quot;,
    &quot;Study_ID&quot;,
    &quot;Enrolled_Date_Time&quot;,
    &quot;New_Intervention_Name&quot;,
    &quot;PI_ID&quot;,
    &quot;AE_Grade_3_Plus&quot;,
    &quot;New_Intervention_Name&quot;,
    &quot;eligible&quot;,
    &quot;Age_40&quot;,
    &quot;Age_65&quot;,
    &quot;Baseline_AE&quot;,
    &quot;New_Int_Name&quot;,
    &quot;Phase&quot;,
    &quot;Randomized&quot;,
    &quot;Combination&quot;,
    &quot;Sponsor_Type&quot;,
    &quot;Disease_Site_Group&quot;
  )



own_check &lt;- own |&gt;
  dplyr::select(Subject_ID, Study_ID, New_Intervention_Name, PI_ID) |&gt;
  dplyr::filter(Subject_ID %in% unique(own_subj_mult_studies_check$Subject_ID)) |&gt;
  dplyr::distinct(Subject_ID, Study_ID, New_Intervention_Name, PI_ID) |&gt;
  dplyr::group_by(Subject_ID, Study_ID, New_Intervention_Name, PI_ID)

own_check &lt;- as.data.frame(own_check)

# length(own_check[!duplicated(own_check$Subject_ID), ]$Subject_ID); #389 unique subjects;
# length(own_check[!duplicated(own_check$Study_ID), ]$Study_ID); #288 unique studies;
# length(own_check[!duplicated(own_check$PI_ID), ]$PI_ID); #41 unique PIs;
# length(own_check[!duplicated(own_check$New_Intervention_Name), ]$New_Intervention_Name); #16 unique interventions;
# length(unique(own_check[duplicated(own_check$Subject_ID), ]$Subject_ID)); #389 subjects in in multiple studies;
# length(own_check[duplicated(own_check$Subject_ID), ]$Subject_ID); #470 instances of subjects in multiple studies;

###have to do New_Intervention_Name in here for correct department;
linkedDataStudies_0 &lt;- own |&gt;
  dplyr::distinct(New_Intervention_Name, Study_ID, Subject_ID, .keep_all = TRUE) |&gt;
  dplyr::group_by(New_Intervention_Name, Study_ID) |&gt;
  dplyr::count(name = &quot;Num_Patients&quot;)


linkedDataStudies &lt;- own |&gt;
  dplyr::select(New_Intervention_Name) |&gt;
  dplyr::group_by(New_Intervention_Name)

linkedDataPIs_0 &lt;- own |&gt;
  dplyr::distinct(PI_ID, New_Intervention_Name, Study_ID, Subject_ID) |&gt;
  dplyr::group_by(PI_ID, New_Intervention_Name, Study_ID) |&gt;
  dplyr::count(name = &quot;Num_Patients&quot;)


linkedDataPIs &lt;- own |&gt;
  dplyr::distinct(PI_ID, New_Intervention_Name, Study_ID) |&gt;
  dplyr::group_by(PI_ID)

linkedDataSubject_ID &lt;- own |&gt;
  dplyr::select(
    Subject_ID,
    Enrolled_Date_Time,
    Study_ID,
    New_Intervention_Name,
    New_Int_Name,
    eligible,
    Combination,
    Randomized,
    AE_Grade_3_Plus,
    Age_65
  ) |&gt;
  dplyr::arrange(
    Subject_ID,
    Enrolled_Date_Time,
    Study_ID,
    New_Intervention_Name,
    New_Int_Name,
    eligible,
    desc(AE_Grade_3_Plus)
  ) |&gt;
  dplyr::group_by(Subject_ID, Study_ID, New_Intervention_Name) |&gt;
  dplyr::filter(row_number() == 1)

reach2=function(x){
  r=vector(length=vcount(x))
  for (i in 1:vcount(x)){
    n=neighborhood(x,2,nodes=i)
    ni=unlist(n)
    l=length(ni)
    r[i]=(l)/vcount(x)}
  r}

reach3=function(x){
  r=vector(length=vcount(x))
  for (i in 1:vcount(x)){
    n=neighborhood(x,3,nodes=i)
    ni=unlist(n)
    l=length(ni)
    r[i]=(l)/vcount(x)}
  r}

dwreach=function(x){
  distances=shortest.paths(x) #create matrix of geodesic distances
  diag(distances)=1 # replace the diagonal with 1s
  weights=1/distances # take the reciprocal of distances
  apply(weights,1,sum) # sum for each node (row)
}

#

fpntable &lt;- table(own$Subject_ID);
otable &lt;- table(own$PI_ID);
rtable &lt;- table(own$New_Intervention_Name);
ownSmall &lt;- own;
three_way_count  &lt;- ownSmall |&gt;
  dplyr::select(PI_ID, New_Intervention_Name, Study_ID, Subject_ID) |&gt;
  dplyr::group_by(PI_ID, New_Intervention_Name, Study_ID, Subject_ID) |&gt;
  dplyr::count(name=&quot;freq&quot;)
three_way_count &lt;- as.data.frame(three_way_count);


edgelist &lt;- cbind(three_way_count$PI_ID, three_way_count$New_Intervention_Name, three_way_count$Study_ID, three_way_count$Subject_ID, three_way_count$freq);

colnames(edgelist) &lt;- c(&quot;PI_ID&quot;, &quot;New_Intervention_Name&quot;, &quot;Study_ID&quot;, &quot;Subject_ID&quot;, &quot;freq&quot;);
edgelist &lt;- as.data.frame(edgelist);
linkedDataPIs_0 &lt;- as.data.frame(linkedDataPIs_0);
linkedDataPIs &lt;- as.data.frame(linkedDataPIs);
linkedDataStudies_0 &lt;- as.data.frame(linkedDataStudies_0);
linkedDataStudies &lt;- as.data.frame(linkedDataStudies);
linkedDataSubject_ID &lt;- as.data.frame(linkedDataSubject_ID);

edgelist0 &lt;- join_all(list(edgelist, linkedDataPIs_0, linkedDataStudies_0), by = c(&quot;New_Intervention_Name&quot;, &quot;Study_ID&quot;), type = &quot;left&quot;, match = &quot;first&quot;);
edgelist00 &lt;- join_all(list(edgelist0, linkedDataSubject_ID), by=c(&quot;Subject_ID&quot;, &quot;New_Intervention_Name&quot;, &quot;Study_ID&quot;), type=&quot;left&quot;, match = &quot;first&quot;);
edgelist00_tibble &lt;- as_tibble(edgelist00);


edgelist &lt;- edgelist00[,colnames(edgelist00) %in% c(&quot;Subject_ID&quot;, &quot;Study_ID&quot;, &quot;Enrolled_Date_Time&quot;, &quot;New_Intervention_Name&quot;, &quot;PI_ID&quot;, &quot;Num_Patients&quot;, &quot;eligible&quot;, &quot;Randomized&quot;, &quot;Combination&quot;, &quot;freq&quot;, &quot;Department&quot;, &quot;Enrolled_Date_Time&quot;, &quot;Status_Change_Date_Time&quot;, &quot;New_Int_Name&quot;, &quot;AE_Grade_3_Plus&quot;, &quot;Age_65&quot;)];

edgelist_count &lt;- length(edgelist$Subject_ID);

n_pi &lt;- length(unique(edgelist$PI_ID));
n_subjects &lt;- length(unique(edgelist$Subject_ID));
n_studies &lt;- length(unique(edgelist$New_Intervention_Name));
strat &lt;- unique(eval(parse(text=paste(&quot;edgelist$&quot;, &quot;eligible&quot;, sep=&quot;&quot;))));
strat &lt;- na.omit(strat);

edgelist &lt;- edgelist[order(edgelist$Subject_ID, edgelist$Enrolled_Date_Time, edgelist$New_Intervention_Name),];
#which(is.na(eval(parse(text=paste(&quot;edgelist$&quot;, var[k], sep=&quot;&quot;))))); #none, good check;

edgelist &lt;- edgelist[,colnames(edgelist) %in% c(&quot;Subject_ID&quot;, &quot;Study_ID&quot;, &quot;New_Intervention_Name&quot;, &quot;PI_ID&quot;, &quot;Num_Patients&quot;, &quot;freq&quot;, &quot;eligible&quot;, &quot;Randomized&quot;, &quot;Combination&quot;, &quot;Department&quot;, &quot;Enrolled_Date_Time&quot;, &quot;Status_Change_Date_Time&quot;, &quot;New_Int_Name&quot;, &quot;AE_Grade_3_Plus&quot;, &quot;Age_65&quot;)];

edgelist$Subject_ID &lt;- as.character(edgelist$Subject_ID);
edgelist$Study_ID &lt;- as.character(edgelist$Study_ID);
edgelist$PI_ID &lt;- as.character(edgelist$PI_ID);
edgelist$New_Intervention_Name &lt;- as.character(edgelist$New_Intervention_Name);
edgelist$freq &lt;- as.numeric(as.character(edgelist$freq));

edgelistPre_st &lt;- edgelist

counterStrat &lt;- length(strat)

st = strat;
strataCat = st;
edgelist &lt;- edgelistPre_st |&gt;
  filter(eval(parse(text=&quot;eligible&quot;)) == st)
edgelist &lt;- as.data.frame(edgelist);
n_studies_strata &lt;- length(unique(edgelist$New_Intervention_Name));

edgelist &lt;- edgelist[order(edgelist$Subject_ID, edgelist$Enrolled_Date_Time, edgelist$New_Intervention_Name),];


###
### DO THIS FOR A SIMPLER DATASET TO CHECK CODE;
###
edgelist &lt;- edgelist |&gt;
  dplyr::arrange(Subject_ID, Enrolled_Date_Time) |&gt;
  dplyr::group_by(Subject_ID) |&gt;
  dplyr::mutate(order = row_number()) |&gt;
  dplyr::mutate(from = Study_ID, 
         to = Study_ID,
         order_from = order, 
         order_to = order)

igraph0 &lt;- edgelist |&gt;
  dplyr::bind_rows(edgelist) |&gt;
  dplyr::arrange(Subject_ID, Study_ID) |&gt;
  dplyr::group_by(Subject_ID,Study_ID) |&gt;
  dplyr::ungroup() |&gt;
  dplyr::group_by(Subject_ID) |&gt;
  dplyr::group_split() |&gt;
  lapply(function(x) x |&gt;
           dplyr::mutate(x, index = 1:nrow(x),
                         direction = ifelse(index%%2 == 1, &quot;from&quot;,&quot;to&quot;))) |&gt;
  do.call(what = rbind) |&gt;
  dplyr::select(Subject_ID, Study_ID, direction) |&gt;
  tidyr::pivot_wider(
    id_cols = c(Subject_ID),
    names_from = direction,
    values_from = c(Study_ID)) |&gt;
  tidyr::unnest(from, .drop=TRUE) |&gt;
  tidyr::unnest(to, .drop=TRUE) 

igraph1 &lt;- plyr::join_all(list(igraph0, edgelist[,c(&quot;Subject_ID&quot;, &quot;from&quot;,
                                                    &quot;order_from&quot;)]), by=c(&quot;Subject_ID&quot;, &quot;from&quot;), type=&#39;left&#39;);
igraph2 &lt;- plyr::join_all(list(igraph1, edgelist[,c(&quot;Subject_ID&quot;, &quot;to&quot;,
                                                    &quot;order_to&quot;)]), by=c(&quot;Subject_ID&quot;, &quot;to&quot;), type=&#39;left&#39;);

igraph2 &lt;- igraph2 |&gt;
  dplyr::filter(order_from &lt; order_to) |&gt;
  dplyr::arrange(Subject_ID, order_from, order_to) |&gt;
  dplyr::group_by(Subject_ID, from) |&gt;
  dplyr::filter(row_number() == 1) |&gt;
  dplyr::mutate(Study_ID_from = from,
                Study_ID_to = to) 

edgelist &lt;- edgelist |&gt;
  dplyr::arrange(Subject_ID, Enrolled_Date_Time) |&gt;
  dplyr::group_by(Subject_ID) |&gt;
  dplyr::mutate(order = row_number()) |&gt;
  dplyr::mutate(New_Intervention_Name_from = New_Intervention_Name, 
                New_Intervention_Name_to = New_Intervention_Name)

igraph3 &lt;- plyr::join_all(list(igraph2, edgelist[,c(&quot;Subject_ID&quot;, &quot;from&quot;, 
                                                    &quot;New_Intervention_Name_from&quot;)]), by=c(&quot;Subject_ID&quot;, &quot;from&quot;), type=&#39;left&#39;);
igraph4 &lt;- plyr::join_all(list(igraph3, edgelist[,c(&quot;Subject_ID&quot;, &quot;to&quot;, 
                                                    &quot;New_Intervention_Name_to&quot;)]), by=c(&quot;Subject_ID&quot;, &quot;to&quot;), type=&#39;left&#39;);
igraph5 &lt;- igraph4 |&gt;
  dplyr::mutate(Study_ID_from = from,
                Study_ID = to,
                from = New_Intervention_Name_from,
                to = New_Intervention_Name_to) |&gt;
  dplyr::select(-c(&quot;New_Intervention_Name_from&quot;, &quot;New_Intervention_Name_to&quot;))

igraph &lt;- igraph5 |&gt;
  dplyr::mutate(from = str_wrap(from, width = 30),
                to = str_wrap(to, width = 30)) |&gt;
  tidygraph::as_tbl_graph(directed = TRUE) |&gt;
  igraph::as.igraph()

e &lt;- igraph::get.edgelist(igraph, names=FALSE);
l &lt;- qgraph::qgraph.layout.fruchtermanreingold(e, vcount=vcount(igraph), area=30*(vcount(igraph)^2),repulse.rad=(vcount(igraph)^2.1));

# ########## Do this for a simpler graph just before plotting;
igraph_simplified &lt;- igraph
E(igraph_simplified)$weight &lt;- 1
igraph_simplified &lt;- igraph::simplify(
  igraph_simplified,
  remove.multiple = T,
  remove.loops = F,
  edge.attr.comb = list(weight = &quot;sum&quot;, &quot;ignore&quot;)
)
E(igraph_simplified)$label &lt;- E(igraph_simplified)$weight


# FOR VISUALS IN THIS REPORT

# Figure 1

g_directed &lt;- graph(c(1, 2, 2, 3, 3, 1), directed = TRUE)
g_undirected &lt;- as.undirected(g_directed)

V(g_directed)$color &lt;- &quot;red&quot;
V(g_undirected)$color &lt;- &quot;red&quot;
E(g_directed)$color &lt;- &quot;black&quot;
E(g_undirected)$color &lt;- &quot;black&quot;
set.seed(5208)
par(mfrow= c(1,2),mar=c(0,0,0,0)+.1)
plot(g_undirected,
     vertex.label = &quot;&quot;,
     edge.arrow.size = 0.5,
     vertex.size = 20)
set.seed(5208)
plot(g_directed,
     vertex.label = &quot;&quot;,
     edge.arrow.size = 0.5,
     vertex.size = 20)

# Figure 2



par(mar=c(0,0,0,0)+1)
plot(
  igraph_simplified,
  edge.label.color = &quot;#801818&quot;,
  edge.label = E(igraph)$label,
  edge.label.cex = 1,
  edge.color = &quot;grey&quot;,
  edge.arrow.size = 0.3,
  vertex.size = 5,
  vertex.shape = &quot;square&quot;,
  vertex.color = &quot;orange&quot;,
  vertex.label = V(igraph)$name,
  vertex.label.cex = 1.0,
  vertex.label.dist = 1.5,
  vertex.label.degree = pi / 2,
  edge.curved = TRUE,
  layout = l
)

# Figure 3


set.seed(5208)
par(mfrow= c(1,1),mar=c(0,0,0,0)+.1)
# Create two clusters
cluster1 &lt;- sample(1:10, 5, replace = FALSE)
cluster2 &lt;- sample(11:20, 5, replace = FALSE)
# Create edges within clusters
edges_within_cluster1 &lt;- t(combn(cluster1, 2))
edges_within_cluster2 &lt;- t(combn(cluster2, 2))
# Create edge connecting the clusters
edge_between_clusters &lt;- matrix(c(sample(cluster1, 1), sample(cluster2, 1)), ncol = 2)
# Combine edges
edges &lt;- rbind(edges_within_cluster1, edges_within_cluster2, edge_between_clusters)
# Create graph
g &lt;- igraph::graph_from_edgelist(edges, directed = FALSE)
# Calculate betweenness centrality
betweenness_values &lt;- igraph::edge_betweenness(g)
# Get the edge with the highest betweenness
max_betweenness_edge &lt;- which.max(betweenness_values)
# Set edge color
igraph::E(g)$color &lt;- &quot;black&quot;
igraph::E(g)[max_betweenness_edge]$color &lt;- &quot;red&quot;
g &lt;- igraph::induced_subgraph(g, which(igraph::degree(g) &gt; 0))
# Plot the graph
plot(
  g,
  vertex.label = &quot;&quot;,
  vertex.color = &quot;grey&quot;,
  edge.curved = FALSE,
  edge.label = NA
)

# Figure 5

set.seed(5208)
par(mfrow= c(1,1),mar=c(0,0,0,0)+.1)

num_nodes &lt;- 6

# Create an empty graph
g &lt;- igraph::make_empty_graph(n = num_nodes)

# Add edges to connect all nodes to the central node (node 1)
for (i in 2:num_nodes) {
  g &lt;- igraph::add_edges(g, c(1, i)) 
}

g |&gt;
  igraph::as.undirected()|&gt;
  plot(
    vertex.label=&quot;&quot;,
    vertex.color = ifelse(igraph::V(g)== 1, &quot;red&quot;, &quot;grey&quot;),
    edge.color = &quot;black&quot;
  )


# Figures 7-10


# Putting this chunk here
gn_igraph &lt;- igraph::cluster_edge_betweenness(igraph)

louvain_igraph &lt;- igraph |&gt;
  igraph::as.undirected() |&gt; 
  igraph::cluster_louvain()

sp_igraph &lt;- igraph |&gt;
  ig.degree.betweenness::cluster_degree_betweenness()


# Figure 7

par(mar=c(0,0,0,0)+1)
plot(
  gn_igraph,
  igraph_simplified,
  edge.label.color = &quot;#801818&quot;,
  edge.label = E(igraph)$label,
  edge.label.cex = 1,
  edge.color = &quot;grey&quot;,
  edge.arrow.size = 0.3,
  vertex.size = 5,
  vertex.shape = &quot;square&quot;,
  vertex.color = &quot;orange&quot;,
  vertex.label = V(igraph)$name,
  vertex.label.cex = 1.0,
  vertex.label.dist = 1.5,
  vertex.label.degree = pi / 2,
  edge.curved = TRUE,
  layout = l
)

# Figure 8

par(mar=c(0,0,0,0)+1)
plot(
  louvain_igraph,
  igraph_simplified,
  edge.label.color = &quot;#801818&quot;,
  edge.label = E(igraph)$label,
  edge.label.cex = 1,
  edge.color = &quot;grey&quot;,
  edge.arrow.size = 0.3,
  vertex.size = 5,
  vertex.shape = &quot;square&quot;,
  vertex.color = &quot;orange&quot;,
  vertex.label = V(igraph)$name,
  vertex.label.cex = 1.0,
  vertex.label.dist = 1.5,
  vertex.label.degree = pi / 2,
  edge.curved = TRUE,
  layout = l
)

# Figure 9

par(mar=c(0,0,0,0)+1)
plot(
  sp_igraph,
  igraph_simplified,
  edge.label.color = &quot;#801818&quot;,
  edge.label = E(igraph)$label,
  edge.label.cex = 1,
  edge.color = &quot;grey&quot;,
  edge.arrow.size = 0.3,
  vertex.size = 5,
  vertex.shape = &quot;square&quot;,
  vertex.color = &quot;orange&quot;,
  vertex.label = V(igraph)$name,
  vertex.label.cex = 1.0,
  vertex.label.dist = 1.5,
  vertex.label.degree = pi / 2,
  edge.curved = TRUE,
  layout = l
)

# Figure 10

all_degree&lt;- igraph::degree(igraph) |&gt; 
  as.data.frame()|&gt;
  tibble::rownames_to_column()|&gt;
  dplyr::rename(degree=`igraph::degree(igraph)` ,
                study=rowname)

in_degree &lt;- igraph::degree(igraph, mode = &quot;in&quot;)|&gt;
 as.data.frame()|&gt;
 tibble::rownames_to_column()|&gt;
 dplyr::rename(in_degree=`igraph::degree(igraph, mode = &quot;in&quot;)` ,
               study=rowname)

out_degree &lt;- igraph::degree(igraph, mode = &quot;out&quot;) |&gt;
   as.data.frame()|&gt;
  tibble::rownames_to_column()|&gt;
  dplyr::rename(out_degree=`igraph::degree(igraph, mode = &quot;out&quot;)` ,
                study=rowname)

degree_df &lt;- merge(in_degree,
                   out_degree)|&gt;
  merge(all_degree)|&gt;
  dplyr::mutate(in_degree = -in_degree)|&gt;
  tidyr::pivot_longer(cols = c(in_degree,out_degree))

ggplot(degree_df,
       mapping = aes(y =reorder(study, degree), x = -value, fill = name))+
  theme_minimal()+
  geom_col()+
  geom_hline(yintercept = 2.5,linetype=&#39;dashed&#39;,lwd=1)+
  geom_hline(yintercept = 12.5,linetype=&#39;dashed&#39;,lwd=1)+
  theme(axis.title.y = element_blank(),
        legend.title = element_blank(),
        legend.position = &quot;bottom&quot;,
        axis.title.x = element_blank())+
  scale_fill_manual(labels = c(&quot;Referrals In&quot;, &quot;Referrals Out&quot;), values = scales::hue_pal()(2))+
  scale_x_continuous(labels = abs)

# Tables

# Table 1

gn_df &lt;- data.frame(
  Intervention = igraph::V(igraph)$name,
  &quot;Patient Refferalls: In&quot; = igraph::degree(igraph,mode=&quot;in&quot;),
  &quot;Patient Referrals: Out&quot; = igraph::degree(igraph, mode=&quot;out&quot;),
  &quot;Total Patient Refferals&quot; =  igraph::degree(igraph, mode=&quot;total&quot;),
  row.names = NULL,
  check.names = FALSE
) |&gt;
  dplyr::group_by(Intervention) |&gt; 
  dplyr::summarise(
    `Refferalls In` = sum(`Patient Refferalls: In`),
    `Referrals Out` = sum(`Patient Referrals: Out`),
    `Total` = sum(`Total Patient Refferals`)
  )

gt::gt(gn_df)|&gt;
  gt::tab_header(&quot;Table 1: Girvan-Newman communities identified. Each intervention is their own community.&quot;)|&gt;
  gt::cols_width(
    Intervention ~ gt::pct(40),
    `Refferalls In` ~ gt::pct(15),
    `Referrals Out`  ~ gt::pct(20),
    `Total` ~ gt::pct(15)
    ) |&gt;
  gt::tab_options(table.font.size=42)



# Table 2

louvain_df &lt;- data.frame(
  Intervention = igraph::V(igraph)$name,
  Community = paste0(&quot;Community: &quot;, igraph::membership(louvain_igraph)|&gt; as.vector()),
  &quot;Patient Refferalls: In&quot; = igraph::degree(igraph,mode=&quot;in&quot;),
  &quot;Patient Referrals: Out&quot; = igraph::degree(igraph, mode=&quot;out&quot;),
  &quot;Total Patient Refferals&quot; =  igraph::degree(igraph, mode=&quot;total&quot;),
  row.names = NULL,
  check.names = FALSE
)

louvain_df |&gt;
  dplyr::group_by(Community,Intervention) |&gt; 
  dplyr::summarise(
    `Refferalls In` = sum(`Patient Refferalls: In`),
    `Referrals Out` = sum(`Patient Referrals: Out`),
    `Total` = sum(`Total Patient Refferals`)
  )|&gt;
  gt::gt()|&gt;
  gt::tab_header(&quot;Table 2: Louvain communities identified and grouped interventions.&quot;)|&gt;
  gt::cols_width(
    Intervention ~ gt::pct(40),
    `Refferalls In` ~ gt::pct(15),
    `Referrals Out`  ~ gt::pct(20),
    `Total` ~ gt::pct(15)
  )|&gt;
  gt::tab_options(table.font.size=42)



# Table 3

sp_df &lt;- data.frame(
  Intervention = igraph::V(igraph)$name,
  Community = paste0(&quot;Community: &quot;, igraph::membership(sp_igraph)|&gt; as.vector()),
  &quot;Patient Refferalls: In&quot; = igraph::degree(igraph,mode=&quot;in&quot;),
  &quot;Patient Referrals: Out&quot; = igraph::degree(igraph, mode=&quot;out&quot;),
  &quot;Total Patient Refferals&quot; =  igraph::degree(igraph, mode=&quot;total&quot;),
  row.names = NULL,
  check.names = FALSE
)

sp_df |&gt;
  dplyr::group_by(Community,Intervention) |&gt; 
  dplyr::summarise(
    `Refferalls In` = sum(`Patient Refferalls: In`),
    `Referrals Out` = sum(`Patient Referrals: Out`),
    `Total` = sum(`Total Patient Refferals`)
  )|&gt;
  gt::gt()|&gt;
  gt::tab_header(&quot;Table 3: Smith-Pittman communities and identified and grouped interventions.&quot;)|&gt;
  gt::cols_width(
    Intervention ~ gt::pct(40),
    `Refferalls In` ~ gt::pct(15),
    `Referrals Out`  ~ gt::pct(20),
    `Total` ~ gt::pct(15)
  )</code></pre>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>For more information, see
https://www.canada.ca/en/health-canada/services/clinical-trials.html<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Quality assurance studies in the context of medical
studies are studies which look at drugs which are already approved for
use but the goals are focused on other aspects of care such as drug
delivery or quality of care.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Named after the author and his co-supervisor, Tyler
Pittman.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Work on extending the Louvain algorithm to accommodate
directed graphs has been an outstanding issue in the igraph community
since 2015 (See: <a
href="https://github.com/igraph/igraph/issues/890">https://github.com/igraph/igraph/issues/890</a>).
However, Dugué and Perez<sup>12</sup> (2022) have done some work on
this.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Short for Monoclonal Antibodies.<a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
